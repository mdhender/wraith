// Code generated by oto; DO NOT EDIT.

package authorization

import (
	"context"
	"net/http"

	"github.com/mdhender/wraith/internal/otohttp"
)

// AuthorizationService makes nice authorizations.
type AuthorizationService interface {

	// Authorize validates the id and secret and returns a signed JWT if successful.
	Authorize(context.Context, AuthorizeRequest) (*AuthorizeResponse, error)
	CreateSigningKeyRequest(context.Context, CreateSigningKeyRequest) (*SigningKeyResponse, error)
}

type authorizationServiceServer struct {
	server               *otohttp.Server
	authorizationService AuthorizationService
}

// Register adds the AuthorizationService to the otohttp.Server.
func RegisterAuthorizationService(server *otohttp.Server, authorizationService AuthorizationService) {
	handler := &authorizationServiceServer{
		server:               server,
		authorizationService: authorizationService,
	}
	server.Register("AuthorizationService", "Authorize", handler.handleAuthorize)
	server.Register("AuthorizationService", "CreateSigningKeyRequest", handler.handleCreateSigningKeyRequest)
}

func (s *authorizationServiceServer) handleAuthorize(w http.ResponseWriter, r *http.Request) {
	var request AuthorizeRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.authorizationService.Authorize(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *authorizationServiceServer) handleCreateSigningKeyRequest(w http.ResponseWriter, r *http.Request) {
	var request CreateSigningKeyRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.authorizationService.CreateSigningKeyRequest(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

// AuthorizeRequest is the request object for AuthorizationService.Authorize.
type AuthorizeRequest struct {
	// Id is the account identifier to authenticate against.
	Id string `json:"id"`
	// Secret is the hex-encoded passphrase used to authenticate the request.
	Secret string `json:"secret"`
}

// AuthorizeResponse is the response object containing the signed JWT if
// authorized.
type AuthorizeResponse struct {
	// Token is the signed JWT if the request is authorized.
	Token string `json:"token"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// CreateSigningKeyRequest is the request object for
// AuthorizationService.CreateSigningKey
type CreateSigningKeyRequest struct {
	// Id is the identifier to assign to the new key.
	Id string `json:"id"`
	// PrivateKey is the hex-encoded key used to sign requests.
	PrivateKey string `json:"privateKey"`
	// PublicKey is the hex-encoded key used to verify signatures.
	PublicKey string `json:"publicKey"`
}

// SigningKeyResponse is the response object containing the public key to verify
// signatures
type SigningKeyResponse struct {
	// PublicKey is the hex-encoded key used to verify signatures.
	PublicKey string `json:"publicKey"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}
